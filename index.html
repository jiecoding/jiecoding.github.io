<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Jay</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Jay">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Jay">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Jay">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Jay" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://jiecoding.github.io/img/ppig.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Jay&#39;s smile</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>標籤</li>
						
						<li>友情链接</li>
						
						
						<li>關於</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="/#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://sanjliu.github.io">Arvin Lau的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.devtang.com">唐巧的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.onevcat.com">王巍的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.txx.im">虾神的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://kittenyang.com">Kitten的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://casatwy.com/category/blog.html">casatwy的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.zengxianhua.com">jack的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.jianshu.com/p/818d121363dd">更多博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Jay&#39;s smile</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://jiecoding.github.io/img/ppig.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Jay&#39;s smile</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="/#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-iOSWisdom" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/10/iOSWisdom/" class="article-date">
  	<time datetime="2016-03-10T03:21:43.000Z" itemprop="datePublished">2016-03-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/10/iOSWisdom/">如何学习iOS</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>   这里说说我自己对学习iOS的一些建议吧</p>
<p>   第一要多读多思考</p>
<p>   这点是必须的,比如一些像我们平时经常使用的gcd core data afnetworking sdwebimage 等等这些我们使用的系统机制或第三方的一些好的库，我们都应该不仅仅是停留在使用的方面，更应该知道他里面的原理,看一遍不懂就多看几次，还有像多看别人的经验,比如tableview的一些优化,比如性能的一些分析,多多思考,思考的时候最好可以记录下来思考的一些结果,这样有助于在实践的时候方便去验证,还有就是苹果提供的一些视频WWDC和文档都是非常好的阅读和思考以及同行交流直播等。</p>
<p>   第二要大量实践</p>
<p>   思考了以后就是动手了,来实践验证自己所想的是不是对的,而且动手实践的好处就是中间会遇到各种各样的问题,问题越是多,说明你提升的空间越大,如果你觉得难,那么不要放弃,你正是在走上坡路.这里为什么说大量实践呢,我们大家都知道熟能生巧这个词,我们的大脑忘记事情会很快,如果你只是做一次,并且只是按照别人的思路来copy很容易忘记.所以只有大量的去实践才能真正领悟.</p>
<p>   第三要疯狂的总结</p>
<p>   总结真的是很关键,如果你一直在开发东西而不去做总结的话,其实你所做过的东西,在以后的时候,很容易忘记,很容易不知道这么久了,进步了哪些?其中遇到了什么问题?自己是怎么解决的?等等..这些好的方法和问题等都是宝贵的财富,因为很多事情都是有关联的,这些问题不会只发生一次,它可能以后会变相出现,也可以下次一模一样,所以总结可以一劳永逸.</p>
<p>   第四要画脑图</p>
<p>   在iOS这个领域里,可能牵扯到太多太多其他的东西,图形学,视频,音频,文字,硬件,通信,动画等等领域,但是这些他们之前的发展一路过来都是历史,无法去改变,这也就让我们能够学到一成不变的经典,一路过来可以画脑图可以更清楚地了解,这些都是你通往专家的道路.但是毕竟每个人的时间有限,需求也不同,兴趣也不同,所以不管是上面哪一个都是要花大量时间去学习去总结去实践和改良的.所以只能说尽量多学点多掌握些吧,或者选择一个专心研究下去,我还是比较提倡一件事情做完再去做另一件事情的.尤其是专业方面的东西.只是先后顺序而已.</p>
<p>   总结,最后要说的是多复习,这点就不多说了,就是对以上的进行复习,多磨合,不然上面的就白做了.温故而知新.上面忘记提书了,看书还是很关键的,如果能把薄书读厚,又能把厚书读薄,就真的非常不错了!愿大家早日变成行业精英,都能够更有兴趣更好的成长,升职 加薪 出任ceo 赢取白富美.</p>
<p><img src="http://jiecoding.github.io/blogImages/donateMe.png"></p>
<p>iOS非闲聊研讨群:328218600</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-iOSSwiftTabBar" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/08/iOSSwiftTabBar/" class="article-date">
  	<time datetime="2016-03-08T03:21:43.000Z" itemprop="datePublished">2016-03-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/08/iOSSwiftTabBar/">Swift tabbarController</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>自定义实现 swift版本的tabbarController，很常用，容易扩展和维护 ，更多好的开源请关注我的github地址</p>
<p>class AppDelegate: UIResponder, UIApplicationDelegate {</p>
<pre><code>var window: UIWindow?


var navigationVC : NSMutableArray!

func controllerWithBarTitle (title : String , viewControllerClass :UIViewController , tag: NSInteger , tabbarIconImageName :String )
{
    let viewController : UIViewController =   viewControllerClass;

    let navigationVC = UINavigationController(rootViewController: viewController);

    let tabbarAPengDaiImage = UIImage(named: tabbarIconImageName);

    navigationVC.tabBarItem = UITabBarItem(title:title,image:tabbarAPengDaiImage,tag:tag);
    if((self.navigationVC) == nil)
    {
        self.navigationVC = NSMutableArray()
    }
    self.navigationVC! .addObject(navigationVC);

}

func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool {
    // Override point for customization after application launch.

    //  UITabBarController
    let tabBarController = UITabBarController();

    self .controllerWithBarTitle(&quot;AAA&quot;, viewControllerClass: AAAViewController(), tag: 1, tabbarIconImageName: &quot;TabBar_HomeNormal.png&quot;);

    self .controllerWithBarTitle(&quot;BB财&quot;, viewControllerClass: InvestmentViewController(), tag: 2, tabbarIconImageName: &quot;TabBar_InvestmentNormal.png&quot;);

    self .controllerWithBarTitle(&quot;CC户&quot;, viewControllerClass: AccountViewController(), tag: 3, tabbarIconImageName: &quot;TabBar_AccountNormal.png&quot;);

    self .controllerWithBarTitle(&quot;邀请好友&quot;, viewControllerClass: InviteViewController(), tag: 4, tabbarIconImageName: &quot;TabBar_InviteNormal.png&quot;);

    print(self.navigationVC);


    tabBarController.viewControllers = self.navigationVC as?[UIViewController];
    /*
    as操作符用来把某个实例转型为另外的类型，由于实例转型可能失败，因此Swift为as操作符提供了两种形式：选项形式as?和强制形式as

    选项形式（as?）的操作执行转换并返回期望类型的一个选项值，如果转换成功则返回的选项包含有效值，否则选项值为 nil 强制形式（as ）的操作执行一个实例到目的类型的强制转换，因此使用该形式可能触发一个运行时错误。
    */

    self.window!.rootViewController = tabBarController;
    /*
    self.window!.和self.window?.区别
    个人理解
    ！ 是强制取值( forced- value) 表达式，
    ？ 是(optional chaining expression) 可选链表达式。
    ?是你不确定opt里面有没有东西,!是你确定里面有东西,当然没有东西的也可以!,但是会分分钟崩溃给你看 ! 号编译器可以分析你的代码

    */


    return true
}
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-iOSWindowViewLayer" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/07/iOSWindowViewLayer/" class="article-date">
  	<time datetime="2016-03-07T03:21:43.000Z" itemprop="datePublished">2016-03-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/07/iOSWindowViewLayer/">UIWindow和UIView和CALayer的联系和区别</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>UIView,UIWindow和CALayer都有共同的基类NSObject,UIView继承于UIResponder,所以UIView可以响应用户事件,CALayer是继承于NSObject所以不可以响应用户事件.UIView侧重于对内容的管理,CALayer侧重于对内容的绘制. UIWindow是特殊的UIView,通常一个app只有一个UIWindow,我们可以创建一个视图控制器,然后将这个视图控制器添加到UIWindow上面,这时这个视图控制器就是app的First Responder.</p>
<p>UIView是视图的基类，UIViewController是视图控制器的基类，UIResponder是表示一个可以在屏幕上响应触摸事件的对象；<br>UIwindow是UIView的子类，UIWindow的主要作用：一是提供一个区域来显示UIView，二是将事件(event)的分发给UIView，一个应用基本上只有一个UIWindow.<br>万物归根，UIView和CALayer都是的老祖都是NSObjet。可见UIResponder是用来响应事件的，也就是UIView可以响应用户事件。<br>　　<br>CALayer和UIView的区别：<br>1.1 UIView的继承结构为: UIResponder : NSObject。<br>CALayer的继承结构为： NSObject。可见UIResponder是用来响应事件的，也就是UIView可以响应用户事件，CALayer直接从NSObject继承，因为缺少了UIResponder类，不能响应任何用户事件。<br>1.2所属框架,UIView是在/System/Library/Frameworks/UIKit.framework中定义的,UIKit主要是用来构建用户界面，并且是可以响应事件的。CALayer是在/System/Library/Frameworks/QuartzCore.framework定义的。而且CALayer作为一个低级的，可以承载绘制内容的底层对象出现在该框架中。<br>1.3 UIView相比CALayer最大区别是UIView可以响应用户事件，而CALayer不可以。UIView侧重于对显示内容的管理，CALayer侧重于对内容的绘制。UIView是基于CALayer的高层封装。<br>1.4相似支持1：相似的树形结构2：显示内容绘制方式3:布局约束<br>总结一下就是：UIView是用来显示内容的，可以处理用户事件.CALayer是用来绘制内容的，对内容进行动画处理依赖与UIView来进行显示，不能处理用户事件</p>
<p><a href="http://tieba.baidu.com/p/4239135997" target="_blank" rel="external">http://tieba.baidu.com/p/4239135997</a><br><a href="http://www.thinksaas.cn/group/topic/396637/" target="_blank" rel="external">http://www.thinksaas.cn/group/topic/396637/</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-iOSNotification" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/05/iOSNotification/" class="article-date">
  	<time datetime="2016-03-05T06:21:43.000Z" itemprop="datePublished">2016-03-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/05/iOSNotification/">iOS里的各种通知及机制</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>通知、本地通知和推送通知区别以及APNS 的机制</p>
<p>对于很多初学者往往会把iOS中的本地通知、推送通知和iOS通知中心的概念弄混。其实二者之间并没有任何关系，事实上它们都不属于一个框架，前者属于UIKit框架，后者属于Foundation框架。</p>
<p>通知中心实际上是iOS程序内部之间的一种消息广播机制，主要为了解决应用程序内部不同对象之间解耦而设计。它是基于观察者模式设计的，不能跨应用程序进程通信，当通知中心接收到消息之后会根据内部的消息转发表，将消息发送给订阅者。</p>
<p>iOS中通知机制又叫消息机制，其包括两类：一类是本地通知；另一类是推送通知，也叫远程通知。<br>两种通知在iOS中的表现一致，可以通过横幅或者弹出提醒两种形式告诉用户，并且点击通知可以会打开应用程序，但是实现原理却完全不同。</p>
<p>本地通知是由本地应用触发的，它是基于时间行为的一种通知形式，例如闹钟定时、待办事项提醒<br>又或者一个应用在一段时候后不使用通常会提示用户使用此应用等都是本地通知。</p>
<p>在iOS中如果点击一个弹出通知（或者锁屏界面滑动查看通知），默认会自动打开当前应用。</p>
<p>由于通知由系统调度那么此时进入应用有两种情况：如果应用程序已经完全退出那么此时会调用- (BOOL)application:(UIApplication <em>)application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions方法；</p>
<p>如果此时应用程序还在运行（无论是在前台还是在后台）则会调用-(void)application:(UIApplication <em>)application didReceiveLocalNotification:(UILocalNotification </em>)notification方法接收消息参数。当然如果是后者自然不必多说，因为参数中已经可以拿到notification对象，只要读取userInfo属性即可。如果是前者的话则可以访问launchOptions中键为UIApplicationLaunchOptionsLocalNotificationKey的对象，这个对象就是发送的通知，由此对象再去访问userInfo。为了演示这个过程在下面的程序中将userInfo的内容写入文件以便模拟关闭程序后再通过点击通知打开应用获取userInfo的过程。</p>
<p>和本地通知不同，推送通知是由应用服务提供商发起的，</p>
<p>通过苹果的APNs（Apple Push Notification Server）发送到应用客户端</p>
<p><a href="http://www.cnblogs.com/kenshincui/p/4168532.html" target="_blank" rel="external">http://www.cnblogs.com/kenshincui/p/4168532.html</a></p>
<p>待补充……</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-iOSABArray" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/05/iOSABArray/" class="article-date">
  	<time datetime="2016-03-05T03:21:43.000Z" itemprop="datePublished">2016-03-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/05/iOSABArray/">两个数组取不同值</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.现有两个无序数组a和b,b中的元素在a中都存在,请设计一个方案,找出在a中,但不在b中的所有元素.请考虑降低时间复杂度.</p>
<p>方法1:    //首先呢,前看看苹果是否提供这类的比较方法<br>很幸运,苹果提供了 NSPredicate,它所属Cocoa框架.利用它可以做类似数据库那样的查询 筛选等..</p>
<p>链接:<a href="http://zhidao.baidu.com/link?url=96djsD_wancK72DLlCQLPuQHzkdAEtsI0J-C8VSh4KNplCn4mOURHoz48Qu8fKqlAhfIkcCge94WAsdmZz7IS-Y-8M8jTBEPAAJ1vut0Jku" target="_blank" rel="external">http://zhidao.baidu.com/link?url=96djsD_wancK72DLlCQLPuQHzkdAEtsI0J-C8VSh4KNplCn4mOURHoz48Qu8fKqlAhfIkcCge94WAsdmZz7IS-Y-8M8jTBEPAAJ1vut0Jku</a></p>
<p>注：NSPredicate所属Cocoa框架,在密码、用户名等正则判断中经常用到.<br>            类似于SQL语句<br>            NOT 不是<br>            SELF 代表字符串本身<br>            IN 范围运算符<br>            那么NOT (SELF IN %@) 意思就是：不是这里所指定的字符串的值<br>实验代码:</p>
<p>NSArray *aArray = [[NSArray alloc] initWithObjects:@”0”,@”8”,@”9”,@”2”,@”1”,@”5”,nil];</p>
<pre><code>NSArray *bArray =  [[NSArray alloc] initWithObjects:@&quot;2&quot;,@&quot;0&quot;,@&quot;1&quot;,@&quot;5&quot;,nil];

NSPredicate * filterPredicate = [NSPredicate predicateWithFormat:@&quot;NOT (SELF IN %@)&quot;,bArray];
//过滤数组
NSArray * reslutFilteredArray = [aArray filteredArrayUsingPredicate:filterPredicate];

NSLog(@&quot;Reslut Filtered Array = %@“,reslutFilteredArray);
</code></pre><p>思考 苹果这样做 时间和复杂程度有哪些好处？</p>
<p>方法2:通过遍历(1)<br>    NSMutableArray <em>reslutArr = [[NSMutableArray alloc] initWithArray:aArray];<br>    for(int i = 0 ; i &lt; aArray.count; i++)<br>    {<br>        NSString </em>aStr = aArray[i];<br>        NSLog(@”aStr:%@”,aStr);<br>        for (int j = 0; j&lt; bArray.count; j++) {<br>            NSString *bStr = bArray[j];<br>            if([aStr isEqualToString:bStr])<br>            {<br>                NSLog(@”%@”,bStr);<br>                [reslutArr removeObject:aStr];<br>                break;<br>            }<br>        }<br>    }<br>    NSLog(@“reslutArr:%@“,reslutArr);</p>
<p>//遍历(2) 对1的优化.   从后往前遍历数组,然后匹配删除.使用containsObject方法的场景很常见,例如:判断某一个元素(对象)是否存在数组中.<br>    int i = (int)[aArray count]-1;<br>    for(;i &gt;= 0;i –){<br>        //containsObject 判断元素是否存在于数组中(根据两者的内存地址判断,相同：YES  不同：NO）<br>        if([bArray containsObject:[aArray objectAtIndex:i]]) {<br>            [aArray removeObjectAtIndex:i];<br>        }<br>    }<br>    NSLog(@”Data Array = %@“,aArray);</p>
<p>//这里的aArray修改成了可变数组 方便removeObject不用定义第三个数组</p>
<p> /<em> 遍历(3) 通过字典key 来进行对另一个数组的remove<br>     时间复杂度为n,一重For循环B数组 考虑b数组比a数组大,换成循环a数组 先将a数组转换成字典,所有元素作为Key  然后遍历B数组,B.元素作为Key到a字典去取值 这样时间复杂度为2n 我说的是纯算法,与具体编程语言无关
     </em>/<br>    NSMutableDictionary <em>dic = [[NSMutableDictionary alloc] init];<br>    for (int i = 0 ;i&lt; aArray.count ; i ++)<br>    {<br>        NSString </em>aKey = aArray[i];<br>        [dic setValue:@”1” forKey:aKey];<br>    }<br>    NSLog(@”dic:%@”,dic);<br>    for (int j = 0; j &lt; bArray.count; j++) {</p>
<pre><code>    NSString *bKey =  bArray[j];
   [dic removeObjectForKey:bKey];
    NSLog(@&quot;dic.allKeys:%@&quot;,dic.allKeys);
}

//思考比较这几种的 时间复杂度,比较下哪个最优？
</code></pre><p>测试两段代码运行速度<br><a href="http://www.cocoachina.com/ios/20100721/1901.html" target="_blank" rel="external">http://www.cocoachina.com/ios/20100721/1901.html</a><br>我打印了下时间 ,通过遍历和方法1 用了 ：<br>谓词和遍历 2016-03-06 11:45:23.717 TestAB[1000:69199] &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;cost time = 0.000007<br>通过字典这种方法用了 2016-03-06 11:46:47.528 TestAB[1036:71234] &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;cost time = 0.000011</p>
<p>也就是说 最好还是用系统自带的谓词或者用自己写的遍历会计算机处理会快一些.当然字典这种也是简便清晰快捷的方法.</p>
<p>具体代码请看我的github地址:<a href="https://github.com/jiecoding/ABArrayAlgorithm" target="_blank" rel="external">https://github.com/jiecoding/ABArrayAlgorithm</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-iOSAnAudition" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/04/iOSAnAudition/" class="article-date">
  	<time datetime="2016-03-04T03:21:43.000Z" itemprop="datePublished">2016-03-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/04/iOSAnAudition/">关于面试</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>刚跳槽去了一个新公司，准备招个高级IOS工程师。于是这周就开始我的面试经历。面试别人，真是让我见识到IT行业的水有多深：<br>第一个：简历上写三年IOS工作经验，简历上一大堆项目，要18k。说上家公司是唯品会，然后说以前做的项目多牛逼啥的。面试结果是一问三不知。<br>第二个：简历上写五年iOS工作经验，西北大学毕业，然后说上家公司倒闭等等之类的。要25k。吹自己多牛逼，一问三不知，一个劲的吹自己创业了没有学习总结，等等如云。<br>第三个：简历上写的两年半iOS，然后以来就给我一个淘宝scrollview的拉动效果，问他怎么实现的，就一句很复杂，一句话说不清楚。撤了一半天以后，我就问他一个关于scrollview的几个属性，让我震惊的一幕发生了，他说：面试无法继续，就走了。。。我操他妈。骗人还有理了，一副吊儿郎当的样子老子见到就烦。<br>第四个：最扯也是最让我反思的一个，34了，简历上写浙大毕业，然后好多工作经验啊，反正也是干iOS都几年了，问他技术问题就一句话：这个我不知道，基本的需求我都会，然后离线保存里几篇博客拿来忽悠我。薪水震惊的要到了30k，要是他值30k，我都不知道要向公司要多少了。<br>第五个：这个是最靠谱的一个也是差点蒙混过关的一个，第一个是他要的薪水11-13k。第二个相对于前面几个一问三不知，他能回答一点，其实我没发现破绽，也准备向公司说要他给11k。结果我的小伙伴点开他说它说在公司的app。。全是近一个月左右上线的，而且全是1.0。总共有几十个。当时让我心里拔凉拔凉的，亏老子对他这么客气。而且我怀疑他说他不舒服是装的，一问到不知道的问题就摸着头，说刚来上海水土不服。有可能是背了一些面试题。</p>
<p>我只想对他们说：你们他妈的就是人渣，以为会做点简单的我功能就牛逼了，而且最可恶的是他们没有一点愧疚感，以为骗人还有理了。太浮躁了。</p>
<p>他们的共同特点是：<br>1 都是几年工作iOS经验，好像一般都是3年左右，最高的达到了吃惊的5年。原来培训出来吹两年工作经验的算有良心得了。<br>2 上家公司要么倒闭，要么是知名企业但是做的事企业内部用的不上线等、要么就是做的知名企业的项目的老版本，然后现在的版本不是他做的。要么上家公司是外包等等如云。<br>3没有技术总结、基本没有博客，没有用github。问看过什么进阶的书一般都说没有。<br>4一来一般都会吹自己做的某个功能特别牛逼。一问详细点就不行了，以各种借口搪塞。<br>5会装，一个屌丝装创业失败、各种想好的故事。<br>6技术能力与他说的iOS工作年限严重不符合。</p>
<p>以上符合两点的就需要仔细甄别。符合三点的一般就是吹得。忘各位同仁擦亮眼睛，别让这种风气继续下去。</p>
<p>我最震惊的是，他们那里来的勇气这样吹？这样高的薪资要。搞的我每次面试以后干活的心情都没有了。哎。。。。。<br>这行真的水太深了，以前还真不知道。shit。。。</p>
<p>上面是一个不知名的博友写的总结，感觉还不错。</p>
<p>我自己的看法是上面这几个无非有两点：<br>1.刚培训出来的。<br>2.工作了很久都是混日子的。</p>
<p>不管是上面哪个，自己感觉都挺不靠谱的，其实都是耽误自己的时间。我还是坚信一寸技术一寸金</p>
<p>当然说完面试者 说说面试官</p>
<p>其实也不能全怪所有的面试者，有的面试官出的题就很2b 简直是用来装逼的 不是用来考人的</p>
<p>就好比我拆过iphone手机 你没有拆过 我就说你没用过苹果手机 你不就是为了装逼你拆过么  </p>
<p>还有问你某个功能在第几个选项这种扯淡的问题，谁能记得那么清楚…</p>
<p>问项目我感觉还是比较靠谱的，毕竟如果真做过的你往深里问就能问出个差不多 , 但是如果蛋疼的为了招一个薪水本来就不是很高的问题，问一大顿操作系统的东西，我觉得脑子里简直有屎。麻烦面试官在面试别人前先想想自己到底要招一个什么样的人，薪水在什么范围的，技术在什么范围的，不要面试的时候连自己都不知道要什么样的人。</p>
<p>对于面试者还是多多提高自身技术，虽然有的时候面试靠碰运气，但是运气几率也是随着综合实力的增加而增加…</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-iOSRuntime" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/02/iOSRuntime/" class="article-date">
  	<time datetime="2016-03-02T03:21:43.000Z" itemprop="datePublished">2016-03-02</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/02/iOSRuntime/">iOS Runtime</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>简单介绍下runtime<br><a href="http://www.cocoachina.com/ios/20141018/9960.html" target="_blank" rel="external">http://www.cocoachina.com/ios/20141018/9960.html</a></p>
<p><a href="http://zhiwei.li/text/2014/08/09/objective-c运行时objc_msgsend_stret/" target="_blank" rel="external">http://zhiwei.li/text/2014/08/09/objective-c运行时objc_msgsend_stret/</a></p>
<p>我们在运行代码的时候 像下面这个方法：</p>
<p> [target doMethodWith:var1];  运行时会转换为 objc_msgSend(target,@selector(doMethodWith:),var1);  C语言函数指针</p>
<p>关于runtime的一些问题：<a href="http://blog.csdn.net/a19860903/article/details/45044701" target="_blank" rel="external">http://blog.csdn.net/a19860903/article/details/45044701</a></p>
<p>第一、文章里面有一个问题：</p>
<p>下面的代码输出什么？</p>
<p>@implementation Son : Father</p>
<ul>
<li>(id)init</li>
</ul>
<p>{</p>
<pre><code>self = [super init];

if (self)

{

    NSLog(@&quot;%@&quot;, NSStringFromClass([self class]));

    NSLog(@&quot;%@&quot;, NSStringFromClass([super class]));

}

return self;
</code></pre><p>}</p>
<p>@end</p>
<p>答案：都输出 Son （前提是father和son类都没有重写class这个方法，而是调用的nsobject的class方法）</p>
<p>首先对于这个题，如果Son类没有重写class方法，而Father类里重写了NSObject的class这个方法，那么[self class] 会去调用父类Father里的class方法，如果想要上面输出: Son 和 Father这种正确的类名，那么就要重写两个类的class方法:</p>
<p>Son.m<br>//- (Class)class OBJC_SWIFT_UNAVAILABLE(“use ‘anObject.dynamicType’ instead”)<br>//{<br>//    return  [Son class];<br>//}</p>
<p>Father.m<br>//- (Class)class OBJC_SWIFT_UNAVAILABLE(“use ‘anObject.dynamicType’ instead”)<br>//{<br>//   return  [Father class];<br>//}</p>
<p>首先这道题，如果你想打印父类，那么就不应该这样写：     </p>
<p>NSLog(@”%@”, NSStringFromClass([super class]));</p>
<p>而是：</p>
<p>NSLog(@”%@”,NSStringFromClass([self superclass]));</p>
<p>达到我们需要的结果后，我们就要思考，上面那段为什么会都输出Son呢，到底进行了什么？</p>
<p>首先前面说到过类似 [self class] 这种 会在运行时转换成 objc_msgSend 函数,objc_msgSend， 它就是负责发送一个消息给对象的C函数</p>
<p>objc-runtime.h 里面 </p>
<p>#include <objc runtime.h=""></objc></p>
<p>#include <objc message.h=""> </objc></p>
<p>objc_msgSend 和 objc_msgSendSuper 就是在message.h 类里</p>
<p>这个函数 objc_msgSend(&lt;#id#&gt;, &lt;#SEL, …#&gt;)<br>有两个参数 </p>
<p>id objc_msgSend(id self, SEL op, …)<br>我们把 self 做为第一个参数传递进去。</p>
<p>id objc_msgSendSuper(struct objc_super *super, SEL op, …)</p>
<p>第一个参数是 objc_super 这样一个结构体，其定义如下:</p>
<p>struct objc_super {</p>
<p>   __unsafe_unretained id receiver;</p>
<p>   __unsafe_unretained Class super_class;</p>
<p>};</p>
<p>结构体有两个成员，第一个成员是 receiver, 类似于上面的 objc_msgSend函数第一个参数self 。第二个成员是记录当前类的父类是什么。<br>…<br>解惑：这个题目主要是考察关于objc中对 self 和 super 的理解。</p>
<p>self 是类的隐藏参数，指向当前调用方法的这个类的实例。</p>
<p>而 super 是一个 Magic Keyword， 它本质是一个编译器标示符，和 self 是指向的同一个消息接受者。</p>
<p>上面的例子不管调用[self class]还是[super class]，接受消息的对象都是当前 Son ＊xxx 这个对象。而不同的是，super是告诉编译器，调用 class 这个方法时，要去父类的方法，而不是本类里的。</p>
<p>Class实际上是存在于内存中的，可以看成是一个特殊的对象 对一个子类发消息，如果子类中找不到对应的方法，会自动向上搜索，直到根类</p>
<p>[super class];在哪个类里写，哪个类就是接收消息的对象 self 指在本类中找到方法 让本类去执行  super 是在编译的时候 让机器去父类或者父类的父类找方法 然后还是本类执行 所以 【super class】 是在父类的父类 也就是NSObject中 找到了这个方法 但是 执行的时候 都是Son 执行的 所以 打印结果就是一样的（个人理解）</p>
<p>具体多看上面的连接，熟能生巧。</p>
<p>待补充</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-iOSUnitTesting" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/03/01/iOSUnitTesting/" class="article-date">
  	<time datetime="2016-03-01T06:15:43.000Z" itemprop="datePublished">2016-03-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/03/01/iOSUnitTesting/">iOS单元测试简单使用</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>单元测试一般我们都不会主动去用，除非有这方面需求，这个东西用起来还是蛮好的。</p>
<p>我们可以对某一个功能进行单独测试，不用整体运行 </p>
<p>只需要在单元测试 <strong><strong><strong><strong><strong>_</strong></strong></strong></strong></strong>Tests.m 加入我们自定义的方法和要测试的内容就可以了。</p>
<p>最简单的例子：</p>
<p>按快捷键Command + U进行单元测试，这个快捷键是全部测试。testExample方法中输入<br> NSLog(@”自定义测试testExample”);<br>    int  a= 3;<br>    XCTAssertTrue(a == 0,”a 不能等于 0”);</p>
<p>自带OCUnit的测试用例最常用的方法有三个：</p>
<ol>
<li><ul>
<li>(void)setUp：每个test方法执行前调用</li>
</ul>
</li>
<li><ul>
<li>(void)tearDown：每个test方法执行后调用</li>
</ul>
</li>
<li><ul>
<li>(void)testXXX：命名为XXX的测试方法</li>
</ul>
</li>
</ol>
<p>我们也可以自己起个方法名字 - (void)xxxx 里面放入我们想要测试的功能。</p>
<p>比如你可以单独测试某个网络接口是否可以使用，不用再一个一个页面进行跳转然后进行测试。</p>
<p>注意：相应的文件链接地址也要在单元测试里配置下。</p>
<p>当然也有一些高级的作用，比如自动发布、自动测试（特别在一些大的项目，以防止程序被误改或引起新的问题）。</p>
<p>这个可以有空研究下…</p>
<p>两篇不错的文章：<a href="http://www.jianshu.com/p/8bbec078cabe" target="_blank" rel="external">http://www.jianshu.com/p/8bbec078cabe</a><br><a href="http://www.cocoachina.com/industry/20130724/6667.html" target="_blank" rel="external">http://www.cocoachina.com/industry/20130724/6667.html</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-iOSDIY NSNotificationCenter" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/02/26/iOSDIY NSNotificationCenter/" class="article-date">
  	<time datetime="2016-02-26T03:21:43.000Z" itemprop="datePublished">2016-02-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/26/iOSDIY NSNotificationCenter/">实现一个自己的NSNotificationCenter</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我一直觉得代码会随着时间的久更新变动的快，但是思想这个东西是越经过时间越经典的一个东西。</p>
<p>如何获取一些好的思想呢？多看别人的代码 多去总结和思考 多交流 分享 面试 等等 都是获取一些好的想法的途径。</p>
<p>接下来进入正题:</p>
<p>如何来实现一个自己的NSNotificationCenter？由于我们看不到源码 所以也不知道苹果具体是怎么实现的。</p>
<p>但是大致肯定的是：系统的通知中心，就是用观察者模式实现的 </p>
<p>NSNotificationCenter是一个单例模式，保存了所有注册的观察者 </p>
<p>当有消息要发送，遍历观察者列表，给对应的观察者转发消息 。</p>
<p>具体代码实现请看我的github地址:</p>
<p><a href="https://github.com/jiecoding/DIYNSNotificationCenter" target="_blank" rel="external">https://github.com/jiecoding/DIYNSNotificationCenter</a></p>
<p>下面的是简单回顾下系统的通知中心(高手可以直接跳过)，对于有什么好的建议请及时提出来，谢谢！</p>
<pre><code>[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(notificationSelector) name:@&quot;notificationName&quot; object:nil];
</code></pre><p>NSNotificationCenter消息通信机制介绍(KVO)</p>
<p>作用:NSNotificationCenter是专门供程序中不同类间的消息通信而设置的.</p>
<p>注册通知:即要在什么地方接受消息<br>               [[NSNotificationCenter defaultCenter]  addObserver:self selector:@selector(mytest:) name:@” mytest” object:nil];<br>      参数介绍:<br>          addObserver:　观察者，即在什么地方接收通知;<br>　       selector:　收到通知后调用何种方法;<br>　       name：　通知的名字，也是通知的唯一标示，编译器就通过这个找到通知的。<br>发送通知:调用观察者处的方法。<br>           [[NSNotificationCenter defaultCenter] postNotificationName:@”mytest”　object:searchFriendArray];<br>          参数：<br>         postNotificationName：通知的名字，也是通知的唯一标示，编译器就通过这个找到通知的。<br>                 object：传递的参数<br>注册方法的写法:</p>
<ul>
<li>(void) mytest:(NSNotification*) notification<br>{<br> id obj = [notification object];//获取到传递的对象<br>} </li>
</ul>
<p>附：注册键盘升启关闭消息</p>
<p>//键盘升起 [[NSNotificationCenter……<br>简单的使用参照:<a href="http://my.oschina.net/gexun/blog/385799" target="_blank" rel="external">http://my.oschina.net/gexun/blog/385799</a></p>
<p>上面简单看了下NSNotificationCenter的使用和简单构成原理。</p>
<p>然后接下来我们思考下，如果我们自己实现应该如何做？</p>
<p>第一步 先创建一个单例 ，然后写添加监听和 发送广播 </p>
<ul>
<li>(DIYNotificationSingle <em>)sharedManager<br>{<br>static DIYNotificationSingle </em>ManagerInstance = nil;<br>  static dispatch_once_t predicate;<br>  dispatch_once(&amp;predicate, ^{<pre><code>ManagerInstance = [[self alloc] init];
</code></pre>   });<br>  return ManagerInstance;<br>} </li>
</ul>
<ul>
<li><p>(void)diyAddObserver:(id)observer selector:(SEL)aSelector name:(nullable NSString *)aName object:(nullable id)anObject<br>{</p>
<pre><code>Entity *entity = [[Entity alloc] init];
entity.observer = observer;
entity.aSelector = aSelector;
entity.notificationName = aName;
  if(!_observers)
  {
      _observers = [[NSMutableArray alloc] init];
  }

[_observers addObject:entity];
</code></pre><p>}</p>
</li>
<li><p>(void)diyPostNotificationName:(NSString <em>)aName object:(nullable id)anObject<br>{<br>  for (Entity </em>observer in _observers)<br>  {</p>
<pre><code>[observer.observer performSelector:observer.aSelector withObject:nil];
</code></pre><p>}</p>
</li>
</ul>
<p>}</p>
<ul>
<li><p>(void)diyRemoveObserver:(id)observer name:(nullable NSString *)aName object:(nullable id)anObject<br>{<br>  for (int i = 0; i &lt; _observers.count ; i++){</p>
<pre><code>Entity *observerE = [_observers objectAtIndex:i];
if([observerE.observer isEqual:observer]){
    [_observers removeObjectAtIndex:i];
}
</code></pre><p>  }<br>  NSLog(@”remove:%@”,_observers);</p>
</li>
</ul>
<p>}<br>关于消息处理方法runtime等 可以预览下 <a href="http://www.cnblogs.com/buro79xxd/archive/2012/04/10/2440074.html" target="_blank" rel="external">http://www.cnblogs.com/buro79xxd/archive/2012/04/10/2440074.html</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-iOSARCLeak" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/02/25/iOSARCLeak/" class="article-date">
  	<time datetime="2016-02-25T05:21:43.000Z" itemprop="datePublished">2016-02-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/02/25/iOSARCLeak/">ARC下内存泄露的一些情况</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>循环引用<br>A有个属性参照B，B有个属性参照A，如果都是strong参照的话，两个对象都无法释放。</li>
</ol>
<p>  这种问题常发生于把delegate声明为strong属性了。</p>
<p>  上例中，解决办法是把SampleClass 的delegate属性的strong改为assing即可。</p>
<ol>
<li><p>死循环</p>
<p>如果某个ViewController中有无限循环，也会导致即使ViewController对应的view关掉了，ViewController也不能被释放。</p>
</li>
</ol>
<p>  这种问题常发生于animation处理。</p>
<p>  CATransition *transition = [CATransition animation];</p>
<p>transition.duration = 0.5;</p>
<p>tansition.repeatCount = HUGE_VALL;</p>
<p>[self.view.layer addAnimation:transition forKey:”myAnimation”];</p>
<p>上例中，animation重复次数设成HUGE_VALL，一个很大的数值，基本上等于无限循环了。</p>
<p>解决办法是，在ViewController关掉的时候，停止这个animation。</p>
<p> 参照资料： <a href="http://www.aichengxu.com/view/30206" target="_blank" rel="external">http://www.aichengxu.com/view/30206</a></p>
<ol>
<li>block的循环引用:</li>
</ol>
<p>这个例子的问题就在于在使用 block 的过程中形成了循环引用：self 持有 networkFetecher；networkFetecher 持有 block；block 持有 self。三者形成循环引用，内存泄露。</p>
<p>4.performSelector 系列<br>performSelector 顾名思义即在运行时执行一个 selector，最简单的方法如下</p>
<ul>
<li>(id)performSelector:(SEL)selector;</li>
</ul>
<p>但 performSelector 相比直接调用更加灵活</p>
<p>SEL selector;<br>if (/<em> some condition </em>/) {<br>    selector = @selector(newObject);<br>} else if (/<em> some other condition </em>/) {<br>    selector = @selector(copy);<br>} else {<br>    selector = @selector(someProperty);<br>}<br>id ret = [object performSelector:selector];</p>
<p>这段代码就相当于在动态之上再动态绑定。在 ARC 下编译这段代码，编译器会发出警告</p>
<p>正是由于动态，编译器不知道即将调用的 selector 是什么，不了解方法签名和返回值，甚至是否有返回值都不懂，所以编译器无法用 ARC 的内存管理规则来判断返回值是否应该释放。因此，ARC 采用了比较谨慎的做法，不添加释放操作，即在方法返回对象时就可能将其持有，从而可能导致内存泄露。</p>
<ol>
<li>在使用 NSTimer addtarget 时，为了防止 target 被释放而导致的程序异常，timer 会持有 target，所以这也是一处内存泄露的隐患。</li>
</ol>
<p>6.try…catch</p>
<p>详细参照:<a href="https://www.zybuluo.com/MicroCai/note/67734" target="_blank" rel="external">https://www.zybuluo.com/MicroCai/note/67734</a><br>觉得总结的不错。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Jay&#39;s smile
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>